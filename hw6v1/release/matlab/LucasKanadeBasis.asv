function [u,v] = LucasKanadeBasis(It, It1, rect, bases)

% input - image at time t, image at t+1, rectangle (top left, bot right
% coordinates), bases 
% output - movement vector, [u,v] in the x- and y-directions.s

[bh, bw, bnf] = size(bases);
bases_vec = reshape(bases, bh*bw, bnf);
lambdas = 0.01*ones(bnf, 1);
base_grads_x = zeros(bh * bw, bnf);
base_grads_y = zeros(bh * bw, bnf);

for i = 1:bnf
    [tempo_x,tempo_y] = imgradientxy(bases(:, :, i));
    base_grads_x(:, i) = tempo_x(:);
    base_grads_y(:, i) = tempo_y(:);
end

% make template
template = It( rect(2):rect(4), rect(1):rect(3));
template_vec = template(:);

% compute image gradient
[I_x_temp,I_y_temp] = imgradientxy(template);
I_x_temp = I_x_temp(:);
I_y_temp = I_y_temp(:);

% get steepest descent
s_d = [I_x_temp + base_grads_x * lambdas  I_y_temp + base_grads_y  * lambdas];

% evaluate Hessian
H = s_d' * s_d;

H_inv = inv(H);

epsilon = 0.005;
new_warp = zeros(2, 1);
delta_warp = ones(2, 1);
It1_warp = It1;
It1_warp_vec = It1_warp(:);
Rin = imref2d(size(It));

while(norm(delta_warp) > epsilon)
    err_im = template_vec + 
    err_im_temp = template - It1_warp( rect(2):rect(4), rect(1):rect(3));
    err_im_temp = err_im_temp(:);
    size(err_im_temp)
    size(s_d)
    
    temp_var = s_d * err_im_temp;
    
    delta_warp = H_inv * temp_var;
    new_warp = new_warp - delta_warp;
    new_warp_33 = [1 0 new_warp(1) ; 0 1 new_warp(2) ; 0 0 1]';
    warp_form = affine2d(new_warp_33);
    
    It1_warp = imwarp(It1, warp_form, 'Linear', 'OutputView', Rin);
    It1_warp_vec = It1_warp(:);
end

u = new_warp(1);
v = new_warp(2);

% scale_size = 4;

% figure, imshow(imresize(It(rect(2):rect(4), rect(1):rect(3)), scale_size, 'nearest'));
% figure, imshow(imresize(It1(rect(2):rect(4), rect(1):rect(3)), scale_size, 'nearest'));
% figure, imshow(imresize(It1_warp(rect(2):rect(4), rect(1):rect(3)), scale_size, 'nearest'));
% figure, imshow(err_im)

% figure, imshow(It)
% figure, imshow(It1)
% figure, imshow(It1_warp)